/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The unique IDs of the tags assigned to the short link.
 */
export type TagIds = string | Array<string>;

/**
 * The unique name of the tags assigned to the short link (case insensitive).
 */
export type TagNames = string | Array<string>;

export type CreateLinkRequestBody = {
  /**
   * The destination URL of the short link.
   */
  url: string;
  /**
   * The domain of the short link. If not provided, the primary domain for the workspace will be used (or `pim.ms` if the workspace has no domains).
   */
  domain?: string | undefined;
  /**
   * The short link slug. If not provided, a random 7-character slug will be generated.
   */
  key?: string | undefined;
  /**
   * The ID of the link in your database. If set, it can be used to identify the link in future API requests (must be prefixed with 'ext_' when passed as a query parameter). This key is unique across your workspace.
   */
  externalId?: string | null | undefined;
  /**
   * The prefix of the short link slug for randomly-generated keys (e.g. if prefix is `/c/`, generated keys will be in the `/c/:key` format). Will be ignored if `key` is provided.
   */
  prefix?: string | undefined;
  /**
   * Whether to track conversions for the short link. Defaults to `false` if not provided.
   */
  trackConversion?: boolean | undefined;
  /**
   * Whether the short link is archived. Defaults to `false` if not provided.
   */
  archived?: boolean | undefined;
  /**
   * The unique ID of the tag assigned to the short link. This field is deprecated â€“ use `tagIds` instead.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  tagId?: string | null | undefined;
  /**
   * The unique IDs of the tags assigned to the short link.
   */
  tagIds?: string | Array<string> | undefined;
  /**
   * The unique name of the tags assigned to the short link (case insensitive).
   */
  tagNames?: string | Array<string> | undefined;
  /**
   * The comments for the short link.
   */
  comments?: string | null | undefined;
  /**
   * The date and time when the short link will expire at.
   */
  expiresAt?: string | null | undefined;
  /**
   * The URL to redirect to when the short link has expired.
   */
  expiredUrl?: string | null | undefined;
  /**
   * The custom link preview title (og:title). Will be used for Custom Social Media Cards if `proxy` is true.
   */
  title?: string | null | undefined;
  /**
   * The custom link preview description (og:description). Will be used for Custom Social Media Cards if `proxy` is true.
   */
  description?: string | null | undefined;
  /**
   * The custom link preview image (og:image). Will be used for Custom Social Media Cards if `proxy` is true.
   */
  image?: string | null | undefined;
  /**
   * The custom link preview video (og:video). Will be used for Custom Social Media Cards if `proxy` is true.
   */
  video?: string | null | undefined;
  /**
   * Allow search engines to index your short link. Defaults to `false` if not provided.
   */
  doIndex?: boolean | undefined;
  /**
   * The UTM source of the short link. If set, this will populate or override the UTM source in the destination URL.
   */
  utmSource?: string | null | undefined;
  /**
   * The UTM medium of the short link. If set, this will populate or override the UTM medium in the destination URL.
   */
  utmMedium?: string | null | undefined;
  /**
   * The UTM campaign of the short link. If set, this will populate or override the UTM campaign in the destination URL.
   */
  utmCampaign?: string | null | undefined;
  /**
   * The UTM term of the short link. If set, this will populate or override the UTM term in the destination URL.
   */
  utmTerm?: string | null | undefined;
  /**
   * The UTM content of the short link. If set, this will populate or override the UTM content in the destination URL.
   */
  utmContent?: string | null | undefined;
  /**
   * The referral tag of the short link. If set, this will populate or override the `ref` query parameter in the destination URL.
   */
  ref?: string | null | undefined;
  /**
   * An array of webhook IDs to trigger when the link is clicked. These webhooks will receive click event data.
   */
  webhookIds?: Array<string> | null | undefined;
};

/**
 * The color of the tag.
 */
export const Color = {
  Red: "red",
  Yellow: "yellow",
  Green: "green",
  Blue: "blue",
  Purple: "purple",
  Pink: "pink",
  Brown: "brown",
} as const;
/**
 * The color of the tag.
 */
export type Color = ClosedEnum<typeof Color>;

export type Tag = {
  /**
   * The unique ID of the tag.
   */
  id: string;
  /**
   * The name of the tag.
   */
  name: string;
  /**
   * The color of the tag.
   */
  color: Color;
};

/**
 * The created link
 */
export type CreateLinkLink = {
  /**
   * The unique ID of the short link.
   */
  id: string;
  /**
   * The domain of the short link. If not provided, the primary domain for the workspace will be used (or `pim.ms` if the workspace has no domains).
   */
  domain: string;
  /**
   * The short link slug. If not provided, a random 7-character slug will be generated.
   */
  key: string;
  /**
   * The destination URL of the short link.
   */
  url: string;
  /**
   * Whether to track conversions for the short link.
   */
  trackConversion?: boolean | undefined;
  /**
   * Whether the short link is archived.
   */
  archived?: boolean | undefined;
  /**
   * The date and time when the short link will expire in ISO-8601 format.
   */
  expiresAt: string | null;
  /**
   * The title of the short link generated via `api.pimms.io/metatags`. Will be used for Custom Social Media Cards if `proxy` is true.
   */
  title: string | null;
  /**
   * The description of the short link generated via `api.pimms.io/metatags`. Will be used for Custom Social Media Cards if `proxy` is true.
   */
  description: string | null;
  /**
   * The image of the short link generated via `api.pimms.io/metatags`. Will be used for Custom Social Media Cards if `proxy` is true.
   */
  image: string | null;
  /**
   * The custom link preview video (og:video). Will be used for Custom Social Media Cards if `proxy` is true.
   */
  video: string | null;
  /**
   * The tags assigned to the short link.
   */
  tags: Array<Tag> | null;
  /**
   * The IDs of the webhooks that the short link is associated with.
   */
  webhookIds: Array<string>;
  /**
   * The comments for the short link.
   */
  comments: string | null;
  /**
   * The full URL of the short link, including the https protocol (e.g. `https://pim.ms/try`).
   */
  shortLink: string;
  /**
   * The full URL of the QR code for the short link (e.g. `https://api.pimms.io/qr?url=https://pim.ms/try`).
   */
  qrCode: string;
  /**
   * The UTM source of the short link.
   */
  utmSource: string | null;
  /**
   * The UTM medium of the short link.
   */
  utmMedium: string | null;
  /**
   * The UTM campaign of the short link.
   */
  utmCampaign: string | null;
  /**
   * The UTM term of the short link.
   */
  utmTerm: string | null;
  /**
   * The UTM content of the short link.
   */
  utmContent: string | null;
  /**
   * The user ID of the creator of the short link.
   */
  userId: string | null;
  /**
   * The workspace ID of the short link.
   */
  workspaceId: string;
  /**
   * The number of clicks on the short link.
   */
  clicks?: number | undefined;
  /**
   * The date and time when the short link was last clicked.
   */
  lastClicked: string | null;
  /**
   * The number of leads the short links has generated.
   */
  leads?: number | undefined;
  /**
   * The date and time when the short link was created.
   */
  createdAt: string;
  /**
   * The date and time when the short link was last updated.
   */
  updatedAt: string;
};

/** @internal */
export const TagIds$inboundSchema: z.ZodType<TagIds, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.array(z.string())]);

/** @internal */
export type TagIds$Outbound = string | Array<string>;

/** @internal */
export const TagIds$outboundSchema: z.ZodType<
  TagIds$Outbound,
  z.ZodTypeDef,
  TagIds
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TagIds$ {
  /** @deprecated use `TagIds$inboundSchema` instead. */
  export const inboundSchema = TagIds$inboundSchema;
  /** @deprecated use `TagIds$outboundSchema` instead. */
  export const outboundSchema = TagIds$outboundSchema;
  /** @deprecated use `TagIds$Outbound` instead. */
  export type Outbound = TagIds$Outbound;
}

export function tagIdsToJSON(tagIds: TagIds): string {
  return JSON.stringify(TagIds$outboundSchema.parse(tagIds));
}

export function tagIdsFromJSON(
  jsonString: string,
): SafeParseResult<TagIds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TagIds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TagIds' from JSON`,
  );
}

/** @internal */
export const TagNames$inboundSchema: z.ZodType<
  TagNames,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type TagNames$Outbound = string | Array<string>;

/** @internal */
export const TagNames$outboundSchema: z.ZodType<
  TagNames$Outbound,
  z.ZodTypeDef,
  TagNames
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TagNames$ {
  /** @deprecated use `TagNames$inboundSchema` instead. */
  export const inboundSchema = TagNames$inboundSchema;
  /** @deprecated use `TagNames$outboundSchema` instead. */
  export const outboundSchema = TagNames$outboundSchema;
  /** @deprecated use `TagNames$Outbound` instead. */
  export type Outbound = TagNames$Outbound;
}

export function tagNamesToJSON(tagNames: TagNames): string {
  return JSON.stringify(TagNames$outboundSchema.parse(tagNames));
}

export function tagNamesFromJSON(
  jsonString: string,
): SafeParseResult<TagNames, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TagNames$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TagNames' from JSON`,
  );
}

/** @internal */
export const CreateLinkRequestBody$inboundSchema: z.ZodType<
  CreateLinkRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  domain: z.string().optional(),
  key: z.string().optional(),
  externalId: z.nullable(z.string()).optional(),
  prefix: z.string().optional(),
  trackConversion: z.boolean().optional(),
  archived: z.boolean().optional(),
  tagId: z.nullable(z.string()).optional(),
  tagIds: z.union([z.string(), z.array(z.string())]).optional(),
  tagNames: z.union([z.string(), z.array(z.string())]).optional(),
  comments: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredUrl: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  video: z.nullable(z.string()).optional(),
  doIndex: z.boolean().optional(),
  utm_source: z.nullable(z.string()).optional(),
  utm_medium: z.nullable(z.string()).optional(),
  utm_campaign: z.nullable(z.string()).optional(),
  utm_term: z.nullable(z.string()).optional(),
  utm_content: z.nullable(z.string()).optional(),
  ref: z.nullable(z.string()).optional(),
  webhookIds: z.nullable(z.array(z.string())).optional(),
}).transform((v) => {
  return remap$(v, {
    "utm_source": "utmSource",
    "utm_medium": "utmMedium",
    "utm_campaign": "utmCampaign",
    "utm_term": "utmTerm",
    "utm_content": "utmContent",
  });
});

/** @internal */
export type CreateLinkRequestBody$Outbound = {
  url: string;
  domain?: string | undefined;
  key?: string | undefined;
  externalId?: string | null | undefined;
  prefix?: string | undefined;
  trackConversion?: boolean | undefined;
  archived?: boolean | undefined;
  tagId?: string | null | undefined;
  tagIds?: string | Array<string> | undefined;
  tagNames?: string | Array<string> | undefined;
  comments?: string | null | undefined;
  expiresAt?: string | null | undefined;
  expiredUrl?: string | null | undefined;
  title?: string | null | undefined;
  description?: string | null | undefined;
  image?: string | null | undefined;
  video?: string | null | undefined;
  doIndex?: boolean | undefined;
  utm_source?: string | null | undefined;
  utm_medium?: string | null | undefined;
  utm_campaign?: string | null | undefined;
  utm_term?: string | null | undefined;
  utm_content?: string | null | undefined;
  ref?: string | null | undefined;
  webhookIds?: Array<string> | null | undefined;
};

/** @internal */
export const CreateLinkRequestBody$outboundSchema: z.ZodType<
  CreateLinkRequestBody$Outbound,
  z.ZodTypeDef,
  CreateLinkRequestBody
> = z.object({
  url: z.string(),
  domain: z.string().optional(),
  key: z.string().optional(),
  externalId: z.nullable(z.string()).optional(),
  prefix: z.string().optional(),
  trackConversion: z.boolean().optional(),
  archived: z.boolean().optional(),
  tagId: z.nullable(z.string()).optional(),
  tagIds: z.union([z.string(), z.array(z.string())]).optional(),
  tagNames: z.union([z.string(), z.array(z.string())]).optional(),
  comments: z.nullable(z.string()).optional(),
  expiresAt: z.nullable(z.string()).optional(),
  expiredUrl: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  image: z.nullable(z.string()).optional(),
  video: z.nullable(z.string()).optional(),
  doIndex: z.boolean().optional(),
  utmSource: z.nullable(z.string()).optional(),
  utmMedium: z.nullable(z.string()).optional(),
  utmCampaign: z.nullable(z.string()).optional(),
  utmTerm: z.nullable(z.string()).optional(),
  utmContent: z.nullable(z.string()).optional(),
  ref: z.nullable(z.string()).optional(),
  webhookIds: z.nullable(z.array(z.string())).optional(),
}).transform((v) => {
  return remap$(v, {
    utmSource: "utm_source",
    utmMedium: "utm_medium",
    utmCampaign: "utm_campaign",
    utmTerm: "utm_term",
    utmContent: "utm_content",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateLinkRequestBody$ {
  /** @deprecated use `CreateLinkRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateLinkRequestBody$inboundSchema;
  /** @deprecated use `CreateLinkRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateLinkRequestBody$outboundSchema;
  /** @deprecated use `CreateLinkRequestBody$Outbound` instead. */
  export type Outbound = CreateLinkRequestBody$Outbound;
}

export function createLinkRequestBodyToJSON(
  createLinkRequestBody: CreateLinkRequestBody,
): string {
  return JSON.stringify(
    CreateLinkRequestBody$outboundSchema.parse(createLinkRequestBody),
  );
}

export function createLinkRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateLinkRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateLinkRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateLinkRequestBody' from JSON`,
  );
}

/** @internal */
export const Color$inboundSchema: z.ZodNativeEnum<typeof Color> = z.nativeEnum(
  Color,
);

/** @internal */
export const Color$outboundSchema: z.ZodNativeEnum<typeof Color> =
  Color$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Color$ {
  /** @deprecated use `Color$inboundSchema` instead. */
  export const inboundSchema = Color$inboundSchema;
  /** @deprecated use `Color$outboundSchema` instead. */
  export const outboundSchema = Color$outboundSchema;
}

/** @internal */
export const Tag$inboundSchema: z.ZodType<Tag, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    name: z.string(),
    color: Color$inboundSchema,
  });

/** @internal */
export type Tag$Outbound = {
  id: string;
  name: string;
  color: string;
};

/** @internal */
export const Tag$outboundSchema: z.ZodType<Tag$Outbound, z.ZodTypeDef, Tag> = z
  .object({
    id: z.string(),
    name: z.string(),
    color: Color$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tag$ {
  /** @deprecated use `Tag$inboundSchema` instead. */
  export const inboundSchema = Tag$inboundSchema;
  /** @deprecated use `Tag$outboundSchema` instead. */
  export const outboundSchema = Tag$outboundSchema;
  /** @deprecated use `Tag$Outbound` instead. */
  export type Outbound = Tag$Outbound;
}

export function tagToJSON(tag: Tag): string {
  return JSON.stringify(Tag$outboundSchema.parse(tag));
}

export function tagFromJSON(
  jsonString: string,
): SafeParseResult<Tag, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tag$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tag' from JSON`,
  );
}

/** @internal */
export const CreateLinkLink$inboundSchema: z.ZodType<
  CreateLinkLink,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  domain: z.string(),
  key: z.string(),
  url: z.string(),
  trackConversion: z.boolean().default(false),
  archived: z.boolean().default(false),
  expiresAt: z.nullable(z.string()),
  title: z.nullable(z.string()),
  description: z.nullable(z.string()),
  image: z.nullable(z.string()),
  video: z.nullable(z.string()),
  tags: z.nullable(z.array(z.lazy(() => Tag$inboundSchema))),
  webhookIds: z.array(z.string()),
  comments: z.nullable(z.string()),
  shortLink: z.string(),
  qrCode: z.string(),
  utm_source: z.nullable(z.string()),
  utm_medium: z.nullable(z.string()),
  utm_campaign: z.nullable(z.string()),
  utm_term: z.nullable(z.string()),
  utm_content: z.nullable(z.string()),
  userId: z.nullable(z.string()),
  workspaceId: z.string(),
  clicks: z.number().default(0),
  lastClicked: z.nullable(z.string()),
  leads: z.number().default(0),
  createdAt: z.string(),
  updatedAt: z.string(),
}).transform((v) => {
  return remap$(v, {
    "utm_source": "utmSource",
    "utm_medium": "utmMedium",
    "utm_campaign": "utmCampaign",
    "utm_term": "utmTerm",
    "utm_content": "utmContent",
  });
});

/** @internal */
export type CreateLinkLink$Outbound = {
  id: string;
  domain: string;
  key: string;
  url: string;
  trackConversion: boolean;
  archived: boolean;
  expiresAt: string | null;
  title: string | null;
  description: string | null;
  image: string | null;
  video: string | null;
  tags: Array<Tag$Outbound> | null;
  webhookIds: Array<string>;
  comments: string | null;
  shortLink: string;
  qrCode: string;
  utm_source: string | null;
  utm_medium: string | null;
  utm_campaign: string | null;
  utm_term: string | null;
  utm_content: string | null;
  userId: string | null;
  workspaceId: string;
  clicks: number;
  lastClicked: string | null;
  leads: number;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const CreateLinkLink$outboundSchema: z.ZodType<
  CreateLinkLink$Outbound,
  z.ZodTypeDef,
  CreateLinkLink
> = z.object({
  id: z.string(),
  domain: z.string(),
  key: z.string(),
  url: z.string(),
  trackConversion: z.boolean().default(false),
  archived: z.boolean().default(false),
  expiresAt: z.nullable(z.string()),
  title: z.nullable(z.string()),
  description: z.nullable(z.string()),
  image: z.nullable(z.string()),
  video: z.nullable(z.string()),
  tags: z.nullable(z.array(z.lazy(() => Tag$outboundSchema))),
  webhookIds: z.array(z.string()),
  comments: z.nullable(z.string()),
  shortLink: z.string(),
  qrCode: z.string(),
  utmSource: z.nullable(z.string()),
  utmMedium: z.nullable(z.string()),
  utmCampaign: z.nullable(z.string()),
  utmTerm: z.nullable(z.string()),
  utmContent: z.nullable(z.string()),
  userId: z.nullable(z.string()),
  workspaceId: z.string(),
  clicks: z.number().default(0),
  lastClicked: z.nullable(z.string()),
  leads: z.number().default(0),
  createdAt: z.string(),
  updatedAt: z.string(),
}).transform((v) => {
  return remap$(v, {
    utmSource: "utm_source",
    utmMedium: "utm_medium",
    utmCampaign: "utm_campaign",
    utmTerm: "utm_term",
    utmContent: "utm_content",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateLinkLink$ {
  /** @deprecated use `CreateLinkLink$inboundSchema` instead. */
  export const inboundSchema = CreateLinkLink$inboundSchema;
  /** @deprecated use `CreateLinkLink$outboundSchema` instead. */
  export const outboundSchema = CreateLinkLink$outboundSchema;
  /** @deprecated use `CreateLinkLink$Outbound` instead. */
  export type Outbound = CreateLinkLink$Outbound;
}

export function createLinkLinkToJSON(createLinkLink: CreateLinkLink): string {
  return JSON.stringify(CreateLinkLink$outboundSchema.parse(createLinkLink));
}

export function createLinkLinkFromJSON(
  jsonString: string,
): SafeParseResult<CreateLinkLink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateLinkLink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateLinkLink' from JSON`,
  );
}
